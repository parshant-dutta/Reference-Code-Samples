
// Dashboard Slide show

import { Component, EventEmitter, OnInit, Output, ViewChild } from '@angular/core';
import { MatDialogRef } from '@angular/material/dialog';
import { Select, Store } from '@ngxs/store';
import * as moment from 'moment';
import { Observable, Subject, Subscription } from 'rxjs';
import { AuthService } from 'src/app/core/auth/services/auth.service';
import { CustomDashboardService } from 'src/app/shared/services/custom-dashboard.service';
import { LoaderService } from 'src/app/shared/services/loader.service';
import Swiper, { SwiperOptions } from 'swiper';
import { SocketService } from 'src/app/shared/services/socket.service';
import { DashboardLevel } from '../models';
import { UpdateSlideShowSettings } from '../../configuration/actions/configuration.actions';
import { ConfigurationState } from '../../configuration/state/configuration.state';
import { SlideShowSettings } from '../../configuration/models/configuration.model';
import { AddDashboardSlide, DeleteDashboardSlide, UpdateDashboardSlide } from '../actions/custom-dashboard.action';
import { DashboardsSubEnum } from '../enums';
import { CustomDashboardState } from '../state/custom-dashboard.state';

@Component({
  selector: 'app-slide-show-modal',
  templateUrl: './slide-show-modal.component.html',
  styleUrls: ['./slide-show-modal.component.scss']
})
export class SlideShowModalComponent implements OnInit {
  @Select(ConfigurationState.getSlideShowConfig) slideShowConfig$: Observable<SlideShowSettings>;
  @Select(CustomDashboardState.getCurrentDashboardLevel) getCurrentDashboardLevel$: Observable<DashboardLevel>;

  @Output() globalSpanData = new EventEmitter<string>();
  @ViewChild('swiper') swiper: Swiper;

  readonly dashboardDataTopicName: string = 'Dashboard';
  readonly slideshowTopicName: string = 'SlideshowSettings';
  readonly dateTimeTopicName: string = 'DateAndTime';

  dashboardLevel: DashboardLevel;

  isPlay: boolean = true;
  index: number = 0;
  delay: number;
  config: SwiperOptions = {};

  slideShowTopicSub: Subscription;
  dashboardTopicSub: Subscription;
  slideShowConfigSub: Subscription;
  currentDashboardLevelSub: Subscription;
  dateTimeTopicSub: Subscription;
  currentServerDateTime: any;
  sockDisonnectSub: Subscription;
  socketReConnectSub: Subscription;
  subscriptionSlideShow: { topic: string; };
  originalDelay: number;
  subscription = new Subscription();
  constructor(
    public authService: AuthService,
    private loaderService: LoaderService,
    private customDashboardService: CustomDashboardService,
    public dialogRef: MatDialogRef<SlideShowModalComponent>,
    private socketService: SocketService,
    public store: Store
  ) {
    this.sockDisonnectSub = this.socketService.socketDisconnectedObservable$.subscribe(() => {
      this.unsubscribeTopics();
    });

    this.socketReConnectSub = this.socketService.socketReConnectedObservable$.subscribe(() => {
      this.realTimeSubscription();
    });
    this.slideShowConfigSub = this.slideShowConfig$.subscribe(res => {
      if (res) {
        this.originalDelay = res.slideDuration || 30;
        this.delay = res.slideDuration || 30;
        this.customDashboardService.setLegendsDurationValue(this.delay);
        this.setSlideConfig();
      }
    });

    this.currentDashboardLevelSub = this.getCurrentDashboardLevel$.subscribe((level) => {
      this.dashboardLevel = level;
    });

    this.subscription.add(this.customDashboardService.serverDateTime().subscribe((response) => {
      if (response?.data) {
        const dateTimeObj = response.data[0];
        this.currentServerDateTime = moment(dateTimeObj.dateTime);
      }
    })
    );
  }

  ngOnInit(): void {
    this.loaderService.showSpinner();

    this.realTimeSubscription();

   this.subscription.add(this.dialogRef.keydownEvents().subscribe(event => {
      if (event.key === "Escape") {
        this.exitSlideShow();
      }
    })
   );

  }

  async dashboardItemUpdate({ action, data }) {
    if (action == DashboardsSubEnum.DashBoardUpdated) {
      this.store.dispatch(new UpdateDashboardSlide(data)).toPromise();
    } else if (action == DashboardsSubEnum.DashBoardDeleted) {
      this.store.dispatch(new DeleteDashboardSlide(data)).toPromise();
    }
  }

  onIndexChange(event) {
    this.customDashboardService.slideShowDestroyed$.next();
    this.customDashboardService.slideShowDestroyed$.complete(); // handle the slide show API cancel mechanism
    this.customDashboardService.slideShowDestroyed$ = new Subject<any>(); // re-initialise the slideShowDestroyed$ observable 
    if(this.dashboardList.length == 1) { // handle the reload slide show if slide length is 1
    this.delay = this.originalDelay;
    if(event == 1) {
      this.delay = .003;
    }
    setTimeout(() => {
      this.setSlideConfig();
    }, 1);
  }
    this.index = event;
  }

  togglePlay() {
    this.isPlay = !this.isPlay;
    if (this.isPlay) {
      this.setSlideConfig();
    }
    else {
      this.config.autoplay = this.isPlay;
    }

  }


  setSlideConfig() {
    this.config = {
      a11y: { enabled: true },
      direction: 'horizontal',
      slidesPerView: 1,
      observer: true,
      observeParents: true,
      speed: 1000,
      autoplay: this.isPlay ? {
        delay: this.convertSecondsToMs(this.delay),
      } : false,
      effect: 'fade',
      fadeEffect: {
        crossFade: true
      },
    }
  }

  onSwiper(swiper) {
    swiper.update();
  }


  exitSlideShow() {
    this.dialogRef.close(this.dashboardList[0]);
  }

  realTimeSubscription() {
    this.subscriptionSlideShow = {
      topic: this.slideshowTopicName,
    }
    // subscribe slideshow duration settings
    this.socketService.sendMessage(this.subscriptionSlideShow);

    this.slideShowTopicSub = this.socketService.getMessage(this.slideshowTopicName).subscribe((res) => {
      try {
        if (res && res.data) {
          this.store.dispatch(new UpdateSlideShowSettings(res.data.slideShow))
        }
      } catch (err) {
      }
    });

    // dashboard topic subscription
    const type = 'new';

    this.socketService.sendMessage({
      topic: this.dashboardDataTopicName,
      id: type
    });

    this.dashboardTopicSub = this.socketService.getMessage(this.dashboardTopicSubscriptionUrl).subscribe(({ action, data }) => {
      try {
        if (action == DashboardsSubEnum.DashBoardCreated && this.dashboardLevel.type == data.type) {
          this.store.dispatch(new AddDashboardSlide(data));
        }
      }
      catch (err) {

      }
    })

    // Date and time topic subscription
    this.socketService.sendMessage({
      topic: this.dateTimeTopicName,
    });

    this.dateTimeTopicSub = this.socketService.getMessage(this.dateTimeTopicName).subscribe((res) => {
      try {
        if (res && res.data) {
          const dateTime = res.data?.dateTime;
          this.currentServerDateTime = moment(dateTime);
        }
      } catch (err) {

      }
    });
  }

  unsubscribeTopics() {
    if (this.subscriptionSlideShow) {
      // Unsbscribe slide show settings topic
      this.socketService.sendMessage(this.subscriptionSlideShow, 'unsubscribe');
    }

    const subscriptionTopicObj1 = { topic: this.dashboardTopicSubscriptionUrl };
    // Unsbscribe dashboard topic
    try {
      this.socketService.sendMessage(subscriptionTopicObj1, 'unsubscribe');
    } catch (err) {

    }

    try {
      const subscriptionDateTime = { topic: this.dateTimeTopicName };
      this.socketService.sendMessage(subscriptionDateTime, 'unsubscribe');
    }
    catch (err) {
    }
    
    this.subscriptionSlideShow = null;
  }


  convertSecondsToMs(seconds: number) {
    return seconds * 1000
  }

  ngOnDestroy() {
    this.unsubscribeTopics();
    this.slideShowConfigSub.unsubscribe();
    this.currentDashboardLevelSub.unsubscribe();
    this.dashboardTopicSub.unsubscribe();
    this.dateTimeTopicSub.unsubscribe();
    this.sockDisonnectSub.unsubscribe();
    this.socketReConnectSub.unsubscribe();
    this.subscription.unsubscribe();
  }

  get dashboardList() {
    const allDashboards = this.customDashboardService.sortedDashboardList(this.dashboardLevel.id);
    return allDashboards.slice(0, 10)
  }

  get dashboardTopicSubscriptionUrl() {
    return this.dashboardDataTopicName + '/new';
  }

  get currentDatetime() {
    return this.currentServerDateTime;
  }

}

